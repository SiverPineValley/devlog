---
title: '2-7) 레코드'
date: 2024-12-07 15:10:00
category: 'kafka'
draft: false
---

</br>

<div align="left">
  <img src="./images/스크린샷 2024-12-07 오후 2.47.10.png" width="500px" />
</div>

</br>

- 레코드는 타임스탬프, 헤더, 오프셋, 메시지 키, 메시지 값으로 구성되어 있다. Producer가 생성한 레코드가 브로커로 전송되면, 타임스탬프와 오프셋이 지정된다. 브로커에 한 번 적재된 데이터는 수정 불가하고, retention 정책(용량/기간)에 의해서만 삭제될 수 있다.
- 레코드의 `타임스탬프(timestamp)`는 스트림 프로레싱에서 활용하기 위해 시간을 저장하는 용도로 사용된다. 카프카 0.10.0.0 이후 버전부터 추가된 타임스탬프는 Unix timestamp가 포함되며, 프로듀서가 따로 설정하지 않으면 기본적으로는 프로듀스 레코드의 생성 시간이 기록된다. `message.timestamp.type`을 지정하면 브로커 적재 시간 (Log Append Time)으로 설정할 수도 있다.
- 레코드의 `오프셋(offset)`은 프로듀서가 전송한 레코드가 브로커에 저장될 때 지정된다. 오프셋은 0부터 시작하여 1씩 증가된다. 컨슈머는 오프셋을 기반으로 처리한 데이터와 앞으로 처리해야 할 데이터를 구분한다. 각 메시지는 파티션별로 고유한 오프셋을 가지므로 컨슈머에서 중복 처리하지 않기 위한 용도로도 사용된다.
- 레코드의 `헤더(header)`는 0.11부터 제공된 기능이다. key/value 데이터를 추가할 수 있으며 레코드의 스키마 버전이나 포맷과 같이 데이터 프로세싱에 참고될만한 정보를 담아 사용할 수 있다.
- `메시지 키(key)`는 처리하고자 하는 메시지를 구분하는 용도로 사용되며, 이를 `파티셔닝(Partitioning)`이라고 한다. 파티셔닝에 사용되는 메시지 키는 `파티셔너(Partitioner)`에 따라 토픽의 파티션 번호가 지정된다. 파티셔너는 레코드가 토픽 내 어느 파티션으로 전해지는 지를 정해주는 역할을 한다. 키는 필수 값이 아니라 값이 없으면 null로 되며 메시지 키가 null인 레코드는 특정 토픽 파티션에 라운드 로빈으로 전해진다. 키 값이 null이 아니면  키의 해쉬값에 따라 특정 파티션에 전달된다. 즉, 같은 키 값의 데이터들은 같은 파티션에 순서대로 전달되므로 순서가 보장된다고 볼 수 있다.
- `메시지 값(value)`은 실절적으로 처리할 데이터가 담기는 공간이다. 메시지 포맷은 제너릭으로 사용자에 의해 정해진다. Float, []Byte, String 등 다양한 형태로 지정 가능하며, 필요에 따라 사용자 지정 포맷으로 직렬화/역직렬화 클래스를 만들어서 사용할 수 있다. 메시지에 어떤 값으로 직렬화/역직렬화되어 저장되었는지 알 수 없으므로 컨슈머는 미리 역직렬화 포맷을 알고 있어야 한다.