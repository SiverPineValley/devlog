---
title: '1) Apache Kafka의 특징과 미래'
date: 2024-12-07 13:00:00
category: 'kafka'
draft: false
---

## 1-1) Apache Kafka의 특징

|특징|상세 설명|
|---|---|
|높은 데이터 처리량|Kafka는 Producer가 브로커로 데이터를 보낼 때, Consumer가 브로커로부터 데이터를 받을 때 묶어서 데이터를 전송한다. 많은 양의 데이터를 송수신할 때 맺어지는 네트워크 비용은 무시할 수 없는 규모인데, Kafka는 더 적은 횟수의 연결로 동일 시간 내에 더 많은 데이터를 처리할 수 있다. 따라서 대용량의 로그성 데이터를 처리하는데 적합하다. 또한, 파티션 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하여 병렬 처리가 가능하다. 파티션 개수만큼 컨슈머 개수를 늘려서 시간당 데이터 처리량을 늘리는 것이다.|
|확장성|데이터 파이프라인에서 데이터가 얼마나 들어올 지 예측하기 어렵다. 언제든지 한순간에 한번에 들어올 수 도 있다. Kafka는 이러한 가변적인 환경에서도 안정적으로 확장 가능하도록 설계되어 있다. 데이터가 많아지면 Kafka 클러스터의 브로커 수를 늘려 자연스럽게 스케일 아웃(Scale-out)할 수 있다. 반대로, 데이터가 적어지면 브로커 수를 줄여 스케일 인(Scale-in)을 할 수 도 있다. 이러한 특성을 통해 무중단 운영이 필요한 커머스나 은행 시스템에서도 안정적인 운영이 가능하다.|
|영속성|데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 의미한다. 다른 메세징 처리 시스템과 다르게 Kafka는 전송받은 데이터를 메모리에 저장하는 것이 아니라, 파일 시스템에 저장한다. 파일 시스템에 저장하는 것은 보편적으로 느리다고 생각되지만, Kafka는 운영 체제 레벨에서 파일 시스템을 최대한 활용하는 방법을 적용하였다. 운영체제에서는 파일 I/O 성능 향상을 위해 페이지 캐시 (page cache) 영역을 메모리에 따로 생성하여 사용한다. 이러한 캐시 기능을 통해 한번 읽은 데이터를 캐싱해두었다가, 다시 사용하는 방식이기 때문에 파일시스템을 이용하더라도 높은 처리량이 유지된다. 또한, 갑작스러운 애플리케이션 장애에도 재시작하면 저장된 파일을 통해 안정적으로 데이터를 재처리 가능하다.|
|고가용성|3개 이상의 브로커로 운영되는 시스템은 Kafka 클러스터 일부에서 장애가 발생하더라도, 무중단으로 안전하고 지속적으로 데이터를 처리할 수 있다. 클러스터로 이루어진 Kafka의 데이터는 복제(replicant)를 통해 고가용성의 특징을 갖는다. 프로듀서로부터 전달받은 데이터를 각 브로커는 다른 브로커에도 복제하여 저장한다. 이에 더해 온프레미스 / 퍼블릭 클라우드의 리전 단위 장애에도 데이터를 안전하게 복제할 수 있는 브로커 옵션들이 준비되어 있다.|

</br>

## 1-2) 대용량 아키텍쳐의 변화
### 1-2-1) 초기 대용량 아키텍쳐

<div align="left">
  <img src="./images/스크린샷 2024-12-07 오후 2.14.32.png" width="500px" />
</div>

</br>

- 초기 대용량 레이크 아키텍처는 위와 같이 원천 데이터 -> 파생 데이터 -> 서빙 데이터를 통해 Data 분석가들에게 제공되었는데, 대부분 배치로 데이터가 전달되므로 유연하지 못하고 실시간 생성 데이터들에 대해 애플리케이션에 빠르게 전달되지 못해서 데이터 히스토리 파악이 힘들고, 파편화되어 데이터 거버넌스 (데이터 표준 및 정책)을 지키기 어려웠다.

</br>

### 1-2-2) 람다 아키텍쳐 (Lamda Architecture)

<div align="left">
  <img src="./images/스크린샷 2024-12-07 오후 2.16.12.png" width="500px" />
</div>

</br>

- 그래서 발전된 것이 람다 아키텍쳐(Lamda Architecture)이다. 람다 아키텍쳐는 3가지 레이어로 나뉘는데, 배치 레이어는 데이터를 특정 시간마다 일괄적으로 처리하여 서빙 레이어에 제공한다. 스피드 레이어는 Kafka와 같이 실시간으로 데이터를 처리하여 서빙 레이어로 전달한다. 스피드 레이어는 배치 레이어에 비해 낮은 지연으로 분석이 필요한 경우에 사용된다. 서빙 레이어는 가공된 데이터를 데이터 사용자, 서비스 애플리케이션에 제공하기 위해 데이터가 저장된 공간이다.
- 람다 아키텍쳐는 데이터를 분석/처리할 수 있는 경우 배치 데이터와 스피드 레이어의 데이터를 융합하여 처리하기 에는 유연하지 못하다는 단점이 있다. 1개의 로직을 추상화하여 배치 레이어와 스피드 레이어에 적용하는 형태를 고안한 서밍버드가 있었지만 완벽히 문제가 해결되지는 못했다.

</br>

### 1-2-3) 카파 아키텍쳐 (Kappa Architecture)

![](https://blog.skby.net/wp-content/uploads/2019/01/2-28.png)

</br>

- 이러한 문제 때문에 고안된 것이 카파 아키텍쳐(Kappa Architecture)이다. 람다 아키텍쳐에서 단점으로 부각되었던 로직의 파편화, 디버깅, 배포, 운영 관리에 대한 이슈를 제거하기 위해 배치 레이어를 아예 삭제하였다.

</br>

<div align="left">
  <img src="./images/스크린샷 2024-12-07 오후 2.21.38.png" width="500px" />
</div>

</br>

- 카파 아키텍쳐로 배치 데이터를 처리하기 위해서는 위와 같이 파티션의 로그를 기반으로 각 시간별 배치 데이터의 스냅샷을 생성함으로써 가능해진다. 각 레코드는 타임스탬프를 가지며, 시간의 변화에 따라 각 배치 데이터의 스냅샷을 생성할 수 있다. 이를 통해 각 시점의 모든 스냅샷을 생성하지 않아도 된다.

</br>

### 1-2-4) 배치 데이터와 스트림 데이터

|배치 데이터|스트림 데이터|
|---|---|
| - 한정된 (bounded) 데이터 처리<br>- 대규모 배치 데이터 처리를 위한 분산<br>- 분, 시간, 일 단위 처리를 위한 지연 발생<br>- 복잡한 키 조인 수행<br> | - 무한 (unbounded) 데이터 처리<br>- 지속적으로 들어오는 데이터를 위한 분산 처리 수행<br>- 분 단위 이하 지연 발생<br>- 단순한 키 조인 수행 |

</br>

### 1-2-5) 스트리밍 데이터 레이크 아키텍쳐 (Streaming Data Lake Architecture)

<div align="left">
  <img src="./images/스크린샷 2024-12-07 오후 2.26.38.png" width="500px" />
</div>

</br>

- 기존 카파 아키텍쳐에서 서빙 레이어까지 제거한 형태의 아키텍쳐. 서빙 데이터에서 처리하던 대용량 데이터를 Kafka에서 오랜 기간 저장하고 사용할 수 있다면, 서빙 레이어를 제거할 수 있다는 관점이다. 이를 해결하기 위해서는 자주 사용되는 데이터와 자주 사용되지 않는 데이터를 구분하여, 자주 사용되는 데이터를 메모리 (Kafka Broker)에 올리고 자주 사용되지 않는 데이터를 오브젝트 스토리지에서 보관할 수 있다.